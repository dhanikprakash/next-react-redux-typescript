{"version":3,"sources":["components/search/searchStyles.ts","components/search/QueryPage.tsx","redux/actions/searchQueryActions.ts","redux/actions/actionTypes.ts","api/apiUtils.ts","redux/actions/searchResultActions.ts","components/search/ResultsPage.tsx","api/searchApi.ts","components/search/SearchContainer.tsx","components/App.tsx","serviceWorker.ts","redux/reducers/initialState.ts","redux/reducers/index.ts","redux/reducers/searchQueryReducer.ts","redux/reducers/searchResultReducer.ts","index.tsx","redux/reducers/configureStore.ts"],"names":["useStyles","makeStyles","root","minWidth","margin","textAlign","title","fontSize","marginBottom","pos","QueryPage","useState","raised","setRaised","classes","searhText","setSearchText","toggleRaised","dispatch","useDispatch","Card","className","onMouseOver","onMouseOut","CardContent","Typography","variant","component","color","gutterBottom","onSubmit","event","preventDefault","console","log","search","query","replace","type","payload","searchQueryActions","noValidate","autoComplete","TextField","id","onChange","target","value","label","Button","handleResponse","response","a","ok","json","status","text","error","Error","defaultState","hasMore","offSet","items","ResultsPage","setOffSet","reduxSearch","useSelector","state","reduxResults","searchResults","result","setResult","useEffect","offset","searchKey","fetch","then","results","loadResults","resultCount","length","concat","toast","warn","position","autoClose","hideProgressBar","closeOnClick","style","height","overflow","dataLength","next","loader","scrollableTarget","List","map","item","key","shortid","generate","ListItem","ListItemAvatar","Avatar","src","artworkUrl100","ListItemText","primary","artistName","secondary","trackName","collectionName","Divider","SearchContainer","App","exact","path","Boolean","window","location","hostname","match","rootReducer","combineReducers","initialState","action","store","composeEnhancers","__REDUX_DEVTOOLS_EXTENSION_COMPOSE__","compose","createStore","applyMiddleware","thunk","reduxImmutableStateInvariant","configureStore","ReactDOM","render","CssBaseline","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.269ca2fe.chunk.js","sourcesContent":["import { makeStyles } from '@material-ui/core/styles';\n\nconst useStyles = makeStyles({\n    root: {\n        minWidth: 275,\n        margin: '30px 30px 0px 30px',\n        textAlign: 'center',\n    },\n    title: {\n        fontSize: 14,\n        marginBottom: 20,\n    },\n    pos: {\n        marginBottom: 20,\n    },\n});\nexport { useStyles }","import * as React from 'react';\nimport { useState } from 'react';\nimport Card from '@material-ui/core/Card';\nimport CardContent from '@material-ui/core/CardContent';\nimport Button from '@material-ui/core/Button';\nimport Typography from '@material-ui/core/Typography';\nimport TextField from '@material-ui/core/TextField';\nimport { useStyles } from './searchStyles';\nimport { useDispatch } from 'react-redux';\nimport { searchQueryActions } from '../../redux/actions/searchQueryActions';\nimport { Search } from '../../../models/models';\n\n\nconst QueryPage: React.FC = () => {\n    const [raised, setRaised] = useState<boolean>(false);\n    const classes: Record<'root' | 'title' | 'pos', string> = useStyles();\n    const [searhText, setSearchText] = useState<string>('');\n    const toggleRaised = (): void => setRaised(!raised);\n    const dispatch = useDispatch();\n\n    const onSearchChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n        setSearchText(event.target.value)\n    }\n\n    const handleSubmit = (event: React.FormEvent): void => {\n        event.preventDefault();\n        console.log('Dispatch Search Query: ' + searhText);\n        const search: Search = { query:searhText.replace(/ /g, '+') };\n        dispatch(searchQueryActions(search))\n    };\n   \n    return (\n        <>\n            <Card\n                className={classes.root}\n                onMouseOver={toggleRaised}\n                onMouseOut={toggleRaised}\n                raised={raised}\n            >\n                <CardContent>\n                    <Typography variant='h5' component='h2'>\n                        Next Front-End Search - Apple API\n          </Typography>\n                    <Typography\n                        className={classes.title}\n                        color='textSecondary'\n                        gutterBottom\n                    >\n                        React/Redux/Thunk/Node/Styled component/FP/Jest/Material UI\n          </Typography>\n\n                    <form onSubmit={handleSubmit} noValidate autoComplete='off'>\n                        <TextField\n                            id='standard-basic'\n                            onChange={onSearchChange}\n                            label='Artist/Album/Song'\n                        />\n                        <Button variant='contained' color='primary' type='submit'>\n                            Search\n            </Button>\n                    </form>\n                </CardContent>\n            </Card>\n        </>\n    )\n}\nexport default QueryPage;","import * as types from './actionTypes';\nimport { Search } from '../../../models/models';\n\ntype Actions = { type: string, payload: Search }\n\nexport const searchQueryActions = (search: Search): Actions => {\n  return { type: types.CREATE_SEARCH, payload: search };\n}","export const CREATE_SEARCH = 'CREATE_SEARCH';\nexport const LOAD_RESULT_SUCCESS = 'LOAD_RESULT_SUCCESS';\n","export async function handleResponse(response: any) {\n  if (response.ok) return response.json();\n  if (response.status === 400) {\n    const error = await response.text();\n    throw new Error(error);\n  }\n  console.log('Network response was not ok.');\n  throw new Error('Network response was not ok.');\n}\n\n// In a real app, call an error logging service.\nexport function handleError(error: any) {\n  console.log('API call failed. ' + error);\n  throw error;\n}\n","import * as types from './actionTypes';\nimport * as searchApi from '../../api/searchApi';\nimport { Results, Search } from '../../../models/models';\n\ntype Actions = { type: string, payload: Results }\n\nexport const loadResultSuccess = (payload: Results): Actions => {\n  return { type: types.LOAD_RESULT_SUCCESS, payload };\n}\n\nexport const loadResults = (offSet: number, search: Search): any => {\n  return async function (dispatch: any) {\n    try {\n      const results = await searchApi.getResults(offSet, search.query);\n      dispatch(loadResultSuccess(results));\n    } catch (error) {\n      // In real app, dispatch error handlers.\n      console.log('Api call error');\n    }\n  };\n}\n","import React, { useState, useEffect } from 'react';\nimport Card from '@material-ui/core/Card';\nimport InfiniteScroll from 'react-infinite-scroll-component';\nimport shortid from 'shortid';\nimport CardContent from '@material-ui/core/CardContent';\nimport List from '@material-ui/core/List';\nimport ListItem from '@material-ui/core/ListItem';\nimport ListItemText from '@material-ui/core/ListItemText';\nimport ListItemAvatar from '@material-ui/core/ListItemAvatar';\nimport Avatar from '@material-ui/core/Avatar';\nimport Divider from '@material-ui/core/Divider';\nimport { toast } from 'react-toastify';\nimport { useStyles } from './searchStyles';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { loadResults } from '../../redux/actions/searchResultActions';\nimport { SearchState } from '../../redux/reducers/initialState';\nimport { Results, Search } from '../../../models/models';\n\ninterface DefaultState {\n  hasMore: boolean,\n  offSet: number,\n  items: any[]\n}\nconst defaultState: DefaultState = {\n  hasMore: false,\n  offSet: 0,\n  items: [],\n};\n\nconst  ResultsPage:React.FC = () =>  {\n\n  const dispatch = useDispatch();\n  const [offSet, setOffSet] = useState<number>(0);\n  const classes: Record<'root' | 'title' | 'pos', string> = useStyles();\n  const reduxSearch: Search = useSelector((state: SearchState) => state.search);\n  const reduxResults: Results = useSelector((state: SearchState) => state.searchResults);\n  const [result, setResult] = useState<DefaultState>(defaultState);\n  const noMatchingResults = (): boolean =>  {\n    return reduxResults.resultCount === 0 &&\n      result.offSet === 0 &&\n      reduxSearch.query != null &&\n      reduxSearch.query !== '';\n  }\n\n  const loadMore = ():void => {\n    setOffSet(result.offSet);\n  };\n\n  useEffect(() => {\n    if (reduxSearch !== null && reduxSearch.query === '') {\n      //reset when searchKey changes\n      setResult(defaultState);\n    }\n      dispatch(loadResults(offSet, reduxSearch));\n  }, [dispatch, reduxSearch, reduxSearch.query, offSet]);\n\n  useEffect(() => {\n    if (reduxResults != null) {\n\n      if(reduxResults.resultCount > 0){\n        setResult({\n          hasMore: reduxResults.results.length > 0,\n          offSet: result.offSet + reduxResults.results.length,\n          items:  result.items.concat(reduxResults.results),\n        });\n      }\n      if (noMatchingResults()) {\n        toast.warn('No Matching Results', {\n          position: 'top-right',\n          autoClose: 3000,\n          hideProgressBar: true,\n          closeOnClick: true,\n        });\n        setResult(defaultState);\n      }\n    }\n  \n  }, [reduxResults]);\n\n  return (\n    <>\n      <Card className={classes.root} raised={true}>\n        <CardContent>\n          <div id='scrollableDiv' style={{ height: 600, overflow: 'auto' }}>\n            <InfiniteScroll\n              dataLength={result.items.length}\n              next={loadMore}\n              hasMore={result.hasMore}\n              loader={<h4>Loading...</h4>}\n              scrollableTarget='scrollableDiv'\n            >\n              <List>\n                {result.items.map((item) => (\n                  <div key={shortid.generate()}>\n                    <ListItem>\n                      <ListItemAvatar>\n                        <Avatar src={item.artworkUrl100}></Avatar>\n                      </ListItemAvatar>\n                      <ListItemText\n                        primary={item.artistName}\n                        secondary={item.trackName + ' - ' + item.collectionName}\n                      ></ListItemText>\n                    </ListItem>\n                    <Divider variant='inset' component='li' />\n                  </div>\n                ))}\n              </List>\n            </InfiniteScroll>\n          </div>\n        </CardContent>\n      </Card>\n    </>\n  );\n}\n\nexport default ResultsPage;","import { handleResponse } from './apiUtils';\nimport {Results} from '../../models/models';\n\nconst baseUrl = 'https://itunes.apple.com/';\nconst limit = 10;\n\nexport function getResults(offset:number, searchKey:string): Promise<Results> {\n    return fetch(baseUrl+`search?media=music&offset=${offset}&limit=${limit}&term=${searchKey}`)\n      .then(handleResponse)\n\n  }","import React from 'react';\nimport QueryPage from './QueryPage';\nimport ResultsPage from './ResultsPage';\n\n\nconst SearchContainer: React.FC = () => {\n    return (\n        <>\n            <QueryPage></QueryPage>\n            <ResultsPage></ResultsPage>\n        </>\n    )\n}\nexport default SearchContainer;","import { BrowserRouter, Route, Switch } from \"react-router-dom\";\nimport SearchContainer from \"./search/SearchContainer\";\nimport { ToastContainer } from \"react-toastify\";\nimport 'react-toastify/dist/ReactToastify.css';\nimport './App.css';\nimport React from \"react\";\n\nconst App: React.FC = () => {\n  return (\n    <>\n      <BrowserRouter>\n        <Switch>\n          <Route exact path=\"/\" component={SearchContainer} />\n        </Switch>\n        <ToastContainer position=\"top-right\" />\n      </BrowserRouter>\n    </>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // 'Content is cached for offline use.' message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import { Results, Result, Search } from '../../../models/models';\n\nexport default {\n  search: { query: '' },\n  searchResults: {\n    resultCount: 0,\n    results: [{}],\n  },\n};\n\nexport type SearchState = {\n  search: Search;\n  searchResults: Results;\n};\n","import { combineReducers } from 'redux';\nimport searchQueryReducer from './searchQueryReducer';\nimport searchResultReducer from './searchResultReducer';\nimport { SearchState } from './initialState'\n\nconst rootReducer = combineReducers<SearchState>({\n  search: searchQueryReducer,\n  searchResults: searchResultReducer,\n});\nexport default rootReducer;\n","import * as types from '../actions/actionTypes';\nimport initialState from './initialState';\nimport { Search } from '../../../models/models';\ntype Actions = { type: string, payload: Search }\n\nexport default function searchQueryReducer(\n  state = initialState.search,\n  action: Actions\n): any {\n  switch (action.type) {\n    case types.CREATE_SEARCH:\n      return {...state, query: action.payload.query}\n    default:\n      return state;\n  }\n}\n","import { Results } from './../../../models/models';\nimport * as types from '../actions/actionTypes';\nimport initialState from './initialState';\n\ntype Actions = { type: string, payload: Results }\n\nexport default function searchResultReducer(\n  state = initialState.searchResults,\n  action: Actions\n): any {\n  switch (action.type) {\n    case types.LOAD_RESULT_SUCCESS:\n      return {...state, \n        resultCount: action.payload.resultCount, \n        results: action.payload.results}\n    default:\n      return state;\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App';\nimport {BrowserRouter as Router} from 'react-router-dom';\nimport * as serviceWorker from './serviceWorker';\nimport configureStore from \"./redux/reducers/configureStore\";\nimport { Provider as ReduxProvider } from \"react-redux\";\nimport CssBaseline from '@material-ui/core/CssBaseline';\nimport { SearchState } from './redux/reducers/initialState';\n\nconst store = configureStore({} as SearchState);\n\n\n\nReactDOM.render(\n\n <ReduxProvider store={store}>\n   <CssBaseline />\n    <Router>\n      <App />\n    </Router>\n  </ReduxProvider>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","import { createStore, applyMiddleware, compose } from 'redux';\nimport rootReducer from './index';\nimport reduxImmutableStateInvariant from 'redux-immutable-state-invariant';\nimport thunk from 'redux-thunk';\nimport { SearchState } from './initialState'\n\ndeclare global {\n  interface Window {\n    __REDUX_DEVTOOLS_EXTENSION_COMPOSE__?: typeof compose;\n  }\n}\n\nexport default function configureStore(initialState: SearchState) {\n  const composeEnhancers =\n    (window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ||\n      compose);\n\n  return createStore(\n    rootReducer,\n    initialState,\n    composeEnhancers(applyMiddleware(thunk, reduxImmutableStateInvariant()))\n  );\n}\n"],"sourceRoot":""}